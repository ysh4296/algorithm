#include <string>
#include <vector>
#include <queue>
#include <iostream>
#include <algorithm>
#define MAX 1e9
//bitmask
using namespace std;
typedef pair<int,pair<int,int>> CN;
typedef pair<int,int> ii;
vector<ii> Edge[1001][2]; // next_node / distance // 0 : active trap , 1 : inactive trap
vector<int> trap_list;
int dist[1001][2049];
bool trapped(int node_num){
    for(int T = 0 ; T < trap_list.size() ; T++){
        if(node_num == trap_list[T]){
            return true;
        }
    }
    return false;
}
int dijkstra(int start, int end){
    priority_queue<CN> q; // cur time/ position / cur trap
    q.push({0,{start,0}});
    
    dist[start][0] = 0;
    while(!q.empty()){
        CN cur = q.top();
        q.pop();
        int cur_dist = -cur.first;
        int cur_node = cur.second.first;
        int cur_trap = cur.second.second;
        int pi = 0;
        for(int T = 0 ; T < trap_list.size() ; T++){ // find next trap situ
            if(cur_node == trap_list[T]){
                    if(((1<<T)&cur_trap) == 0) { // not trapped yet
                        pi = 0;
                    }
                    else { // active
                        pi = 1;
                    }
            }
        }
        for(ii next : Edge[cur_node][0]){
            for(int T = 0 ; T < trap_list.size() ; T++){ // find next trap situ
                if(next.first == trap_list[T]){
                        if(((1<<T)&cur_trap) != 0) { // not trapped yet
                            pi = !pi;
                        }
                }
            }
        }
        for(ii next : Edge[cur_node][1]){
            for(int T = 0 ; T < trap_list.size() ; T++){ // find next trap situ
                if(next.first == trap_list[T]){
                        if(((1<<T)&cur_trap) != 0) { // not trapped yet
                            pi = !pi;
                        }
                }
            }
        }
        if(dist[cur_node][cur_trap] < cur_dist) continue;
        for(int next_edge = 0 ; next_edge < Edge[cur_node][pi].size() ; next_edge++){
            int next_node = Edge[cur_node][pi][next_edge].first;
            int next_dist = cur_dist+Edge[cur_node][pi][next_edge].second;
            int npi = 0,next_trap = 0;
            for(int T = 0 ; T < trap_list.size() ; T++){ // find next trap situ on next node
                if(next_node == trap_list[T]){
                    if(((1<<T)&cur_trap) == 0) { // not trapped yet
                        next_trap = (1<<T)+cur_trap;
                        npi = 1;
                    }
                    else {
                        next_trap = (1<<T)-cur_trap;
                        npi = 0;
                    }
                }
            }
            for(ii next : Edge[next_node][0]){
                for(int T = 0 ; T < trap_list.size() ; T++){ // find next trap situ
                    if(next.first == trap_list[T]){
                            if(((1<<T)&cur_trap) != 0) { // not trapped yet
                                npi = !npi;
                            }
                    }
                }
            }
            for(ii next : Edge[next_node][1]){
                for(int T = 0 ; T < trap_list.size() ; T++){ // find next trap situ
                    if(next.first == trap_list[T]){
                            if(((1<<T)&cur_trap) != 0) { // not trapped yet
                                npi = !npi;
                            }
                    }
                }
            }
            if(dist[next_node][next_trap] > next_dist){
                dist[next_node][next_trap] = next_dist;
                q.push({-next_dist,{next_node,next_trap}});
            }
        }
    }
    int ans = MAX;
    for(int i = 0 ; i < 2049 ; i++) ans = min(ans,dist[end][i]);
    return ans;
}
int solution(int n, int start, int end, vector<vector<int>> roads, vector<int> traps) {
    int answer = 0;
    for(int i = 0 ; i < 1001 ; i++) {
        for(int j = 0 ; j < 2049 ; j++){
            dist[i][j] = MAX;
        }
    }
    for(int i = 0 ; i < roads.size() ; i++){
        Edge[roads[i][0]][0].push_back({roads[i][1],roads[i][2]});
        Edge[roads[i][1]][1].push_back({roads[i][0],roads[i][2]});
    }
    for(int i = 0 ; i < traps.size() ; i++) trap_list.push_back(traps[i]);
    
    answer = dijkstra(start,end);
    return answer;
}
